# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

#### Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

#### Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
#### нужно прервать. 

#### Вы как инженер поддержки решили произвести данную операцию:
#### - напишите список операций, которые вы будете производить для остановки запроса пользователя
 - Уточнить непосредственно запрос у разработчика
 - Проверить все ли хорошо с системой. В mongo-shell выполнить команду `db.enableFreeMonitoring()` и пройти 
по ссылке из ответа. Изучить графики на предмет деградации системы.
```json
{
        "state" : "enabled",
        "message" : "To see your monitoring data, navigate to the unique URL below. Anyone you share the URL with will also be able to view this page. You can disable monitoring at any time by running db.disableFreeMonitoring().",
        "url" : "https://cloud.mongodb.com/freemonitoring/cluster/W2MLWR5W7ZVMSLGD6C4XXNLXSFVOSCPA",
        "userReminder" : "",
        "ok" : 1
}
```
 - В mongo-shell выполнить команду `db.currentOp({"secs_running":{$gte:5}})` и вычислить проблемные запросы
 - Использовать db.killOp() для завершения запроса
#### - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
 - С помощью .explain("executionStats") узнать информацию о исполнении запроса и оптимизировать его  
 - Создать необходимые индексы  
 - Установить maxTimeMS() для установления лимита на опрецию, чтобы не навредить всей системе 1 запросом


## Задача 2

#### Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

#### Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
#### Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
#### увеличивается пропорционально количеству реплик сервиса. 

#### При масштабировании сервиса до N реплик вы увидели, что:
#### - сначала рост отношения записанных значений к истекшим
#### - Redis блокирует операции записи

#### Как вы думаете, в чем может быть проблема?
 - Врядли это связано с потенциальной проблемой с TTL, когда в один момент времени нужно удалить более 25% истекших ключей 
т.к. по условию сказано что она постоянна и при подключении новых нод не возрастет. 
 - Думаю Redis настроен не просто в режиме кеша, а с хранением данных на диске. Возникла проблема с диском - Redis при попытке  
по таймауту удалить старые записи заблокировал возможность писать на диск новые, что вызвало рост новых ключей, которые добавлялись, в памяти
 - Redis заблокировал операции записи т.к. в итоге master вышел из строя, изза проблемы с диском, и произошло переключение на slave, 
который настроен только для чтения

## Задача 3

#### Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

#### Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
#### пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

#### Как вы думаете, почему это начало происходить и как локализовать проблему?
  Т.к. соединение теряется во время выполнения запроса, то логично предположить что дело в нем=) Скорее всего он долго 
выполняется. Причина может быть как в том что в запросе передается очень много данных и превышается лимит времени на 
чтение данных полученных по сети, так и в времени выполнения SELECT - неправильно составлен запрос или разрослась база 
#### Какие пути решения данной проблемы вы можете предложить?
  - Нужно проанализировать сам запрос и оптимизировать его
  - Еси дело в том что с запросом передается много данных - можно увеличить лимит net_read_timeout
  - Если вопрос во времени выполнения запроса и он уже оптимизирован - возможно нужно проверить и создать необходимые индексы 
или настроить, если не было, шардирование. Это позволит ускорить скорость выполнения

## Задача 4

#### Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

#### Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
#### большим объемом данных лучше, чем MySQL.

#### После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

#### Как вы думаете, что происходит?
 Скорее всего серверу не хватило памяти для каких либо нужд - например при установлении нового соединения или при 
выполнении большого select.  
Хотя запросить память мог и другой процесс, а oom киллер прибел того кто потребляет больше всего.

#### Как бы вы решили данную проблему?
 - Если выясниться что сама БД не потребляет много ресурсов, и упала изза другого процесса - можно изменить настройку ядра 
 vm.oom_kill_allocating_task - тогда будет убиваться сам процесс запросивший память, которой не хватает.
 - Может БД уже не хватает ресурсов - увеличиваем кол-во ресурсов или настраиваем репдикацию
 - Если дело в запросе - ищем его, профилируем, оптимизируем
 - Настраиваем нужные индексы
 - Настраиваем шардинг