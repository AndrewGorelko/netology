1. #### Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
    Команда cd - builtin т.е. встроена в интерпретатор. Это так потому что команда должна изменить текущую дирректорию для 
   текущего окружения, а если она будет запускаться как отдельно исполняемой, то она будет менять дирректроию в другом дочернем процессе и окружении
2. #### Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
    `grep -c <some_string> <some_file>`
3. #### Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
   `systemd`
4. #### Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
   Смотрим какой файл /dev/pts/* использует процесс `lsof -p $$`. Из другого терминала `echo message > /dev/pts/1`
5. #### Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
   `cat < 1.txt > 2.txt`
6. #### Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
   `echo message > /dev/tty6` или `echo message > /proc/proc_tty/fd/0`. Ctrl+f6 - смотрим наше сообщение. Это на локальном ПК. 
7. #### Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
   `bash 5>&1` для текущего процееса создаст файловый дескриптор 5 (/proc/$$/fd/5) как силинк на стандартный вывод stdout текущего процесса (/proc/$$/fd/1). 
   Соответсвенно `echo netology > /proc/$$/fd/5` перенаправит сообщение netology в файл 5, а оттуда в файл /proc/$$/fd/1 подключенный как stdout к терминалу в котором мы работаем. На экране появится слово  `netology`
8. #### Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
   Создем промежуточный файловый дескриптор и перенаправляем его на стандартный вывод `bash 3>&1`. 
   Перенаправление `командна 2>&1 1>&3 | команда`. Живой пример: в дирректории 3 файла и 1 дирректория. 
   В файлах текст hi `grep hi * 2>&1 1>&3 | wc -l` выведет результат grep - 1.txt:hi 2.txt:hi echo:hi и посчитает кол-во ошибок - 1
9. #### Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
   Выводит переменные окружения для текущего процесса или сессии. Анологичный вывод можно получить с помощью утилит `env` `printenv` `set`
10. #### Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
   `/proc/<PID>/cmdline` - Доступный только для чтения файл. Содержит полную командную строку запуска процесса т.е как он был запущен. Если процесс зомби в этом файле ничего не будет  
   `/proc/<PID>/exe` - указатель или символическая ссылка на исполняемый файл. Выполнив эту команду можно запустить копию процесса  
11. #### Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.    
   `cat /proc/cpuinfo | grep sse` - sse4_2  
12. #### При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:  

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```
	#### Почитайте, почему так происходит, и как изменить поведение.  
    
    При задании параметра `command` для `ssh` не пытается подключиться к терминалу, а пытается выполнить команду без создания tty. Для решения можно использовать флаг `-t` - принудительное выделение терминала  
13. #### Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.  
    > ssh localhost 'ping 8.8.8.8'----> 64 bytes from 8.8.8.8: icmp_seq=41 ttl=63 time=27.7 ms  
    CTRL-Z  
    jobs -l -----> [1]+ 13555 Stopped ssh localhost 'ping 8.8.8.8'  
    disown 13555 -----> warning: deleting stopped job 1 with process group 13555  
    jobs -l - пусто  
    screen или tmux работает и там и там  
    reptyr 13555 ---->  64 bytes from 8.8.8.8: icmp_seq=398 ttl=63 time=27.1 ms  
    CTRL-B + D - detach
    
   Все сделано по мануалу [reptyr](https://github.com/nelhage/reptyr#readme) в github  

14. #### `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать. `echo` -  выводит текст на экран  
   `tee` - читает stdin и пишет в stdout. Говорят удобно использовать как прослойку для вывода промежуточного stdout. Например `grep hi * | tee tee.txt | wc -l`. В tee.txt -> 1.txt:hi  
    Разница в том что `sudo echo string > /root/new_file` пытается записать файл перенаправлением, а перенаправлением занимается процесс shell'а, который запущен без sudo под нашим пользователем, а команда tee запущена с помощью sudo и выполняется от su. Соответсвенно может писать файлы в /root дирректории